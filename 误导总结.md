# 记录生活中的一些'Bug'与不明白的问题

## 深拷贝与浅拷贝的问题

```js

var a = [1, 2, 3];
var b = a;
a = [1, 2];

---------

var a = {a: 1, b: 2};
var b = a;
a = {a: 1};


// 注意： 这时b页发生了变化（b浅拷贝了a，b是复杂类型，所以指针指向了a，a发生变化，b页跟着变化了）
 
 解决思路： 
 1. 数组解决：
        var a = [1, 2, 3];
        var b = [];
        var b = b.concat(...a);
 2. 对象解决：
        function deepCopy(obj){
         var result = Array.isArray(obj)?[]:{};
         for(var key in obj){
           if(obj.hasOwnProperty(key)){
             if(typeof obj[key]==="object"){
               result[key] = deepCopy(obj[key]); //递归复制
             }else{
               result[key] = obj[key];
             }
              }
            }
          return result;
        }
```

## 对象问题

```js
var num = 1;
var obj = {
  a: !function() {console.log(num)}()
}

// 每此点击后num加一
dom.onclick = function() {
  num += 1;
  // 注意：obj中的a是函数自执行，所以进入页面只会执行一次，函数只会记录一次，后续是获取这个函数，而不是重新调用这个函数，所以不会获取到最新的num！
  console.log(obj.a);
}

```

## 监听函数连续触发的问题

> 需求，在滚动到图片的可视区域后展示该图片
> 问题：如果一直监听滚动事件从而会导致性能问题
> 解决：利用函数节流技术

代码：

```js
  /**
   * @param {Function, Number} - fn -> 一秒后需要做的事情  delay -> 多久执行一次事件
   * 函数节流
   *  
   */
  thorttle = function(fn, delay) {
    let curTime;
    let beforeTime;
    
    // 判断之前的时间加上延迟事件如果大于当前时间，说明还没有执行1s，就清除定时器，（不执行任何东西）
    if( beforeTime && curTime < beforeTime + delay ) {
      clearTimeOut(time)
      time = setTimeOut(function() {
        beforeTime = new Data()
        apply(this, arguments)
      })
    } else {
      // 第一次进入函数会执行这行判断中
      // 设置上次执行的时间
      beforeTime = new Data();
      fn.apply(this, arguments);
    }
  }

  window.addEventListener('scroll', thorttle(scrollTop, 1000))
```

> 当然，有些需求只需要根据最后监听结果来执行相应的事件
> 解决：函数防抖动技术

代码：
```js
    // 函数防抖(函数只执行一次！！！)
   const decounce = function (fn, delay) {
      let timer = null

      return function () {
        const context = this
        let args = arguments
        clearTimeout(timer) // 每次调用debounce函数都会将前一次的timer清空，确保只执行一次
        timer = setTimeout(() => {
          fn.apply(context, args)
        }, delay)
      }
    }

    let num = 0

    function scrollTap() {
      num++
    }

    window.addEventListener('scroll', decounce(scrollTap, 500))
```

## toFixed()

> 注意`toFixed方法会四舍五入`
> 解决:

代码:
```js
  // 保留两位小数不会进行四舍五入
  toDecimal(num) {
    return +(parseInt(num * 100) / 100).toFixed(2)
  },
```

## 函数柯里化

> 函数复用，将函数多参数转单参数技术

```js
  function getUrl (url1, url2, url3) {
    return url1 + url2 + url3;
  }

  ||

  function getUrl (url1, url2, url3) {
    return url1 * url2 * url3
  }

  // 每次调用
  var url = getUrl(1, 2, 3);
  // 再次调用
  var url = getUrl(1, 2, 4);
  // 注意：每次调用都写相同的函数，前面参数也相同，那我们怎么处理好一点呢？
  function curry (func) {
    var urls = Array.prototype.sclie(arguments, 1);
    // urls -> [1, 2];
    return function (url) {
      func.call(this, urls, url)
    }
  }
  
  var cur = curry(function(a, b, c) { a * b * c}, url1, url2);
  var cur = curry(function(a, b, c) { a + b + c}, url1, url2);
  // 调用
  cur(url3);
```